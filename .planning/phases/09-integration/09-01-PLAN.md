---
phase: 09-integration
plan: 01
type: execute
---

<objective>
Wire background coaching loop on MCP server startup with end-to-end testing.

Purpose: Complete v1.1 Voice Coaching by connecting all voice components into an autonomous background loop that monitors game state and provides proactive coaching.
Output: Working background coaching loop that triggers advice on game events, with MCP tools for control.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (dependency chain):
@.planning/phases/07-coach-engine/07-01-SUMMARY.md
@.planning/phases/08-mcp-voice-tools/08-01-SUMMARY.md

# Key source files:
@src/arenamcp/server.py
@src/arenamcp/coach.py

**Tech stack available:**
- CoachEngine with Claude/Gemini/Ollama backends
- GameStateTrigger for detecting: new_turn, priority_gained, combat_attackers, combat_blockers, low_life, opponent_low_life, stack_spell
- VoiceInput (PTT/VOX), VoiceOutput (Kokoro TTS)
- queue_advice() for proactive advice queue
- get_game_state() returns full game state dict

**Established patterns:**
- Lazy-loaded voice components (_voice_input, _voice_output)
- Thread-safe deque for advice queue
- Protocol-based LLM backends with factory function
- Error strings returned instead of exceptions for resilience

**Constraining decisions:**
- Phase 7: Use Protocol for LLMBackend interface (duck typing)
- Phase 8: queue_advice() ready for background loop integration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create background coaching loop</name>
  <files>src/arenamcp/server.py</files>
  <action>
Add a background coaching loop that runs in a daemon thread:

1. Create `_coaching_thread` and `_coaching_enabled` module-level state
2. Create `_background_coaching_loop()` function that:
   - Stores previous game state for trigger comparison
   - Polls get_game_state() every 1-2 seconds
   - Uses GameStateTrigger.check_triggers() to detect state changes
   - For each trigger, calls CoachEngine.get_advice() with the trigger
   - Calls queue_advice() with the result
   - Optionally calls _get_voice_output().speak() if auto_speak enabled
   - Catches exceptions to keep loop running (log errors, don't crash)
   - Checks _coaching_enabled flag to allow stopping

3. Create `start_background_coaching(backend: str = "claude", auto_speak: bool = False)` function that:
   - Creates CoachEngine with specified backend via create_backend()
   - Creates GameStateTrigger instance
   - Starts the background thread (daemon=True so it dies with main process)
   - Sets _coaching_enabled = True

4. Create `stop_background_coaching()` function that:
   - Sets _coaching_enabled = False
   - Waits for thread to finish (with timeout)

Import CoachEngine, GameStateTrigger, create_backend from arenamcp.coach.
Use threading.Thread for background loop. Do NOT use asyncio (FastMCP uses sync handlers).
  </action>
  <verify>Python syntax check: `python -m py_compile src/arenamcp/server.py`</verify>
  <done>Background loop functions exist, can be started/stopped, polls game state and detects triggers</done>
</task>

<task type="auto">
  <name>Task 2: Add MCP tools for coaching control</name>
  <files>src/arenamcp/server.py</files>
  <action>
Add MCP tools to control background coaching:

1. `start_coaching(backend: str = "claude", auto_speak: bool = False)` tool:
   - Calls start_background_coaching() with parameters
   - Returns {"started": True, "backend": backend, "auto_speak": auto_speak}
   - Returns {"error": message} if already running or backend invalid

2. `stop_coaching()` tool:
   - Calls stop_background_coaching()
   - Returns {"stopped": True}
   - Returns {"error": "not running"} if not active

3. `get_coaching_status()` tool:
   - Returns {"active": bool, "backend": str or None, "auto_speak": bool}
   - Shows current coaching configuration

Store backend name and auto_speak setting in module-level state for status reporting.

Tool docstrings should explain:
- start_coaching: Begins background game monitoring with proactive advice
- stop_coaching: Stops background monitoring
- get_coaching_status: Check if coaching is active and its configuration
  </action>
  <verify>Python syntax check passes, tools show up in `python -c "from arenamcp.server import mcp; print([t.name for t in mcp._tool_manager._tools.values()])"`</verify>
  <done>Three new MCP tools for coaching control, can start/stop/query background coaching</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete v1.1 voice coaching system with background monitoring</what-built>
  <how-to-verify>
    1. Start MTGA and enter a game (or use existing Player.log with game data)
    2. Start the MCP server: `python -m arenamcp.server`
    3. In Claude Code, test the full flow:
       a. Call get_game_state() - verify it returns game data
       b. Call start_coaching(backend="claude", auto_speak=False)
       c. Wait for game state changes (new turn, combat, etc.)
       d. Call get_pending_advice() - verify advice was queued
       e. Call speak_advice() with the advice text - verify TTS works
       f. Call stop_coaching()
       g. Call get_coaching_status() - verify shows inactive
    4. Optional: Test with auto_speak=True to hear proactive advice
    5. Verify no crashes or errors in server output
  </how-to-verify>
  <resume-signal>Type "approved" if end-to-end flow works, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -m py_compile src/arenamcp/server.py` passes
- [ ] Background coaching loop starts without errors
- [ ] GameStateTrigger detects game state changes
- [ ] Advice gets queued via queue_advice()
- [ ] MCP tools work: start_coaching, stop_coaching, get_coaching_status
- [ ] No blocking of MCP server main thread
- [ ] Clean shutdown when stop_coaching() called
</verification>

<success_criteria>

- All tasks completed
- Background coaching loop monitors game state
- Proactive advice generated on triggers (new_turn, combat, low_life, etc.)
- MCP tools control coaching lifecycle
- End-to-end flow verified with Claude Code
- Phase 9 complete = v1.1 Voice Coaching milestone complete
</success_criteria>

<output>
After completion, create `.planning/phases/09-integration/09-01-SUMMARY.md`:

# Phase 9 Plan 1: Integration Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `src/arenamcp/server.py` - Description

## Decisions Made

[Key decisions and rationale]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

v1.1 Voice Coaching milestone complete. System ready for use.
</output>
