---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Implement log parser that accumulates multi-line JSON blocks and routes events via callbacks.

Purpose: Transform raw log text into structured events that game state can consume.
Output: LogParser class that extracts GreToClientEvent, GameStateMessage, MatchCreated from log stream.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**MTGA log format:**
- Lines prefixed with `[UnityCrossThreadLogger]` or `[Client GRE]` markers
- JSON payloads span multiple lines (opening brace, content, closing brace)
- Critical message types:
  - `GreToClientEvent` - contains game state updates
  - `GameStateMessage` - board state snapshot
  - `MatchCreated` - new game started
- JSON embedded in log lines, not on their own lines

**Example log structure:**
```
[UnityCrossThreadLogger]12:34:56.789 GreToClientEvent
{
  "greToClientEvent": {
    "gameStateMessage": {
      "gameObjects": [...],
      "turnInfo": {...}
    }
  }
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement multi-line JSON accumulator</name>
  <files>src/arenamcp/parser.py</files>
  <action>
Create LogParser class that accumulates and parses multi-line JSON from log stream:

1. State machine for JSON accumulation:
   - Track brace depth (increment on '{', decrement on '}')
   - When depth returns to 0, attempt JSON parse
   - Buffer lines between first '{' and final '}'

2. process_chunk(text: str) method:
   - Split incoming text into lines
   - For each line:
     - If not in JSON block and line contains '{': start accumulating, track depth
     - If in JSON block: append to buffer, update depth
     - If depth == 0: parse complete JSON, emit event, reset buffer
   - Handle partial lines at chunk boundaries (store incomplete line for next chunk)

3. Error handling:
   - Catch json.JSONDecodeError - log warning, discard buffer, continue
   - Handle malformed brackets gracefully (reset on obvious corruption)

4. Event emission via callback: on_event(event_type: str, payload: dict)

Don't over-engineer - this is a streaming parser, not a full lexer. The log format is predictable.
  </action>
  <verify>
Test with sample log content:
```python
parser = LogParser(on_event=lambda t, p: print(f"{t}: {p.keys()}"))
parser.process_chunk('[UnityCrossThreadLogger] GreToClientEvent\n{"test": "value"}\n')
# Should emit event
```
  </verify>
  <done>
- JSON blocks spanning multiple lines are correctly accumulated
- Partial chunks at boundaries handled (no lost data)
- Malformed JSON logged and skipped, doesn't crash parser
  </done>
</task>

<task type="auto">
  <name>Task 2: Add event type detection and routing</name>
  <files>src/arenamcp/parser.py</files>
  <action>
Extend LogParser to detect and route specific MTGA event types:

1. Event type detection from log line markers:
   - Look for patterns like `GreToClientEvent`, `MatchCreated`, `ClientToMatchServiceMessage`
   - Store detected event type when starting JSON accumulation
   - Extract from line preceding the '{' or from the JSON content itself

2. Key event types to detect:
   - `GreToClientEvent` - most important, contains game state
   - `MatchCreated` - signals new game, reset state
   - `GameStateMessage` - nested in GreToClientEvent, but may appear standalone
   - `MulliganReq` / `MulliganResp` - opening hand decisions

3. Callback signature: on_event(event_type: str, payload: dict)
   - event_type is the detected type string
   - payload is the parsed JSON dict

4. Add method to register typed callbacks:
   - register_handler(event_type: str, handler: Callable[[dict], None])
   - Allow multiple handlers per event type
   - Default handler catches unregistered types (for debugging)

Keep event detection simple - string matching on known patterns. Don't parse the full log line grammar.
  </action>
  <verify>
```python
parser = LogParser()
events = []
parser.register_handler('GreToClientEvent', lambda p: events.append(('gre', p)))
parser.register_handler('MatchCreated', lambda p: events.append(('match', p)))
parser.process_chunk(sample_gre_event)
parser.process_chunk(sample_match_created)
assert len(events) == 2
```
  </verify>
  <done>
- Event types correctly detected from log markers
- Typed handlers receive only their registered events
- Unknown events don't crash (logged or sent to default handler)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire watcher to parser with integration test</name>
  <files>src/arenamcp/__init__.py, tests/test_integration.py</files>
  <action>
Create integration that connects watcher → parser:

1. In __init__.py, create convenience factory:
   ```python
   def create_log_pipeline(log_path: str = None) -> tuple[MTGALogWatcher, LogParser]:
       parser = LogParser()
       watcher = MTGALogWatcher(log_path=log_path, callback=parser.process_chunk)
       return watcher, parser
   ```

2. Create tests/test_integration.py with:
   - Test that writes to temp file, verifies events flow through pipeline
   - Use tempfile for isolated test log
   - Write realistic MTGA log snippets
   - Verify event callbacks fire correctly

3. Add pytest to dev dependencies in pyproject.toml

4. Include sample log snippets as test fixtures (from design doc or create realistic examples)

Focus on proving the watcher→parser→callback chain works end-to-end.
  </action>
  <verify>pytest tests/test_integration.py -v passes</verify>
  <done>
- Integration test proves watcher feeds parser correctly
- Sample MTGA log content parsed into typed events
- Pipeline factory function available for easy setup
- Phase 1 foundation complete and tested
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from arenamcp.parser import LogParser"` imports
- [ ] JSON accumulation handles multi-line blocks
- [ ] Event types detected and routed to handlers
- [ ] pytest tests pass
- [ ] Integration test proves end-to-end flow
</verification>

<success_criteria>
- LogParser accumulates multi-line JSON correctly
- Event type detection works for GreToClientEvent, MatchCreated
- Watcher→Parser integration proven with test
- Foundation ready for Phase 2 game state management
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`

**Note:** This completes Phase 1. Update ROADMAP.md progress table when done.
</output>
