---
phase: 02-game-state
plan: 01
type: execute
---

<objective>
Build GameState class that maintains complete game snapshot from parsed log events.

Purpose: Core state tracking enables all downstream features (MCP tools, card lookup, opponent history)
Output: GameState class with zone tracking, player state, and history; integrated with LogParser
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Source files from Phase 1:
@src/arenamcp/parser.py
@src/arenamcp/__init__.py

**Tech stack available:** Python 3.10+, watchdog
**Established patterns:**
- Handler registration: parser.register_handler(event_type, callback)
- Pipeline factory: create_log_pipeline() returns configured components
- Streaming parser: process_chunk() for incremental processing

**Key data structures (from MTGA logs):**
- GameStateMessage contains: gameObjects, zones, players, turnInfo
- gameObjects: list of {instanceId, grpId, zoneId, ownerSeatId, ...}
- zones: list of {zoneId, type, ownerSeatId, objectInstanceIds}
- players: list of {seatId, lifeTotal, ...}
- turnInfo: {activePlayer, priorityPlayer, phase, step, turnNumber}
- grpId maps to Scryfall arena_id (external card lookup - Phase 3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameState class with zone tracking</name>
  <files>src/arenamcp/gamestate.py</files>
  <action>
Create GameState class with:
- Zone dataclasses: Zone(type, owner, objects), GameObject(instance_id, grp_id, zone_id, owner)
- ZoneType enum: BATTLEFIELD, HAND, GRAVEYARD, EXILE, LIBRARY, STACK, LIMBO, COMMAND
- Main state: zones dict by zone_id, game_objects dict by instance_id
- Player dataclass: Player(seat_id, life_total, mana_pool)
- TurnInfo dataclass: TurnInfo(turn_number, active_player, priority_player, phase, step)
- Convenience properties: battlefield, hand, graveyard (filtering by zone type)
- get_objects_in_zone(zone_type, owner=None) method
- get_player_objects(seat_id) method for objects owned by player

Keep structures simple - just data containers for now. No complex logic.
  </action>
  <verify>python -c "from arenamcp.gamestate import GameState, ZoneType, GameObject, Player, TurnInfo; gs = GameState(); print('OK')"</verify>
  <done>GameState importable with zone tracking structures, ZoneType enum, Player and TurnInfo dataclasses</done>
</task>

<task type="auto">
  <name>Task 2: Implement state update from GameStateMessage events</name>
  <files>src/arenamcp/gamestate.py</files>
  <action>
Add method to GameState:
- update_from_message(payload: dict) - handles GameStateMessage structure
- Extract gameObjects list -> update/create GameObjects, index by instance_id
- Extract zones list -> update Zone objects with type, owner, object lists
- Extract players list -> update Player objects by seat_id
- Extract turnInfo -> update TurnInfo

Handle incremental updates:
- GameStateMessage can be full or partial (diff)
- Full messages have "type": "GameStateType_Full"
- Diff messages update only changed objects
- For simplicity, treat all updates as upserts (create or update)

Add factory that connects to parser:
- create_game_state_handler(game_state: GameState) -> handler function
- Handler extracts GameStateMessage from GreToClientEvent payloads
- Wire into parser: parser.register_handler('GreToClientEvent', handler)
  </action>
  <verify>python -c "from arenamcp.gamestate import GameState, create_game_state_handler; gs = GameState(); h = create_game_state_handler(gs); print('OK')"</verify>
  <done>GameState.update_from_message() processes GameStateMessage, create_game_state_handler() factory exists</done>
</task>

<task type="auto">
  <name>Task 3: Add opponent card history tracking</name>
  <files>src/arenamcp/gamestate.py, src/arenamcp/__init__.py</files>
  <action>
Extend GameState:
- opponent_seat_id property (seat that isn't local player)
- played_cards: dict[int, list[int]] mapping seat_id to list of grp_ids seen
- Track cards when they first appear in non-library zones (hand, battlefield, graveyard, etc.)
- _seen_instances: set[int] to avoid double-counting same card instance
- get_opponent_played_cards() -> list[int] of grp_ids opponent has revealed

Update __init__.py:
- Export GameState, create_game_state_handler from package
- Add to __all__

Add local_seat_id property to GameState (needs to be set externally when MatchCreated event provides seat assignments).
  </action>
  <verify>python -c "from arenamcp import GameState, create_game_state_handler; gs = GameState(); gs.local_seat_id = 1; print(gs.get_opponent_played_cards())"</verify>
  <done>Opponent history tracking works, GameState exported from package, local_seat_id configurable</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from arenamcp import GameState"` succeeds
- [ ] GameState has zones, players, turn_info attributes
- [ ] update_from_message() handles sample GameStateMessage structure
- [ ] get_opponent_played_cards() returns list of grp_ids
- [ ] All existing tests still pass: `python -m pytest tests/`
</verification>

<success_criteria>

- GameState class with full zone and player tracking
- Event handler integration with LogParser
- Opponent card history tracking
- Package exports updated
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-game-state/02-01-SUMMARY.md`
</output>
