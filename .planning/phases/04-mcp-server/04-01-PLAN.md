---
phase: 04-mcp-server
plan: 01
type: execute
---

<objective>
Create FastMCP server exposing MTGA game state and card information via STDIO transport.

Purpose: Enable Claude to access live game state, card oracle text, opponent history, and draft statistics during MTGA gameplay - completing the "Calculator + Coach" pattern where deterministic code tracks state and LLM provides analysis.

Output: Working MCP server with four tools: get_game_state(), get_card_info(), get_opponent_played_cards(), get_draft_rating()
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Existing modules to integrate:**
@src/arenamcp/watcher.py - MTGALogWatcher class with watchdog monitoring
@src/arenamcp/parser.py - LogParser class with event routing
@src/arenamcp/gamestate.py - GameState class with zones, objects, players, turns
@src/arenamcp/scryfall.py - ScryfallCache with arena_id lookup
@src/arenamcp/draftstats.py - DraftStatsCache with 17lands data

**Key patterns from PROJECT.md:**
- Calculator + Coach: Include oracle text in serialization so LLM has card context
- STDIO transport for lowest latency
- Tools over Resources (MCP Resources don't support server-push)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP server module with FastMCP setup</name>
  <files>src/arenamcp/server.py, src/arenamcp/__init__.py</files>
  <action>
Create server.py with:

1. FastMCP server initialization with name="mtga" and STDIO transport
2. Module-level instances for global state:
   - game_state: GameState instance
   - scryfall: ScryfallCache instance (lazy-loaded to avoid blocking startup)
   - draft_stats: DraftStatsCache instance
   - parser: LogParser with GreToClientEvent handler wired to game_state
   - watcher: MTGALogWatcher (not started by default - started on first tool call or explicit start)

3. Lifecycle management:
   - start_watching() function to begin log monitoring
   - Watcher feeds chunks to parser, parser updates game_state

4. Helper function enrich_with_oracle_text(grp_id) that:
   - Looks up card in scryfall cache
   - Returns dict with name, oracle_text, type_line, mana_cost
   - Returns minimal dict with just grp_id if lookup fails (graceful degradation)

Update __init__.py to export the server entry point.

Use `mcp = FastMCP("mtga")` pattern. Do NOT import scrython - use the existing ScryfallCache class which uses requests directly.
  </action>
  <verify>python -c "from arenamcp.server import mcp; print(mcp.name)"</verify>
  <done>server.py exists with FastMCP instance, lifecycle functions, and oracle text helper</done>
</task>

<task type="auto">
  <name>Task 2: Implement MCP tools</name>
  <files>src/arenamcp/server.py</files>
  <action>
Add four MCP tools using @mcp.tool() decorator:

1. get_game_state() -> dict:
   - Returns complete board state snapshot
   - Structure: {
       "turn": {turn_number, active_player, priority_player, phase, step},
       "players": [{seat_id, life_total, mana_pool, is_local}],
       "battlefield": [card objects with oracle text],
       "hand": [card objects - local player only],
       "graveyard": [card objects],
       "stack": [card objects],
       "exile": [card objects]
     }
   - Each card object includes: instance_id, grp_id, name, oracle_text, type_line, mana_cost, owner_seat_id, controller_seat_id, power, toughness, is_tapped
   - Calls enrich_with_oracle_text() for each game object
   - If watcher not started, auto-start it

2. get_card_info(arena_id: int) -> dict:
   - Looks up card by arena_id via ScryfallCache
   - Returns: {name, oracle_text, type_line, mana_cost, cmc, colors, scryfall_uri}
   - Returns {"error": "Card not found"} if not found

3. get_opponent_played_cards() -> list[dict]:
   - Gets grp_ids from game_state.get_opponent_played_cards()
   - Enriches each with oracle text via ScryfallCache
   - Returns list of {grp_id, name, oracle_text, type_line, mana_cost}
   - Empty list if no opponent or no cards played yet

4. get_draft_rating(card_name: str, set_code: str) -> dict:
   - Looks up via DraftStatsCache.get_draft_rating()
   - Returns: {name, set_code, gih_wr, alsa, iwd, games_in_hand}
   - Returns {"error": "Card not found"} if not found
   - gih_wr is decimal 0.0-1.0 (e.g., 0.55 = 55% win rate)

Tool docstrings should be clear for LLM consumption - explain what each returns and when to use it.
  </action>
  <verify>python -c "from arenamcp.server import mcp; print([t.name for t in mcp._tool_manager._tools.values()])"</verify>
  <done>All four tools registered and callable, returning properly structured data</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from arenamcp.server import mcp"` imports without error
- [ ] `python -c "from arenamcp.server import mcp; print(mcp.name)"` prints "mtga"
- [ ] All four tools registered: get_game_state, get_card_info, get_opponent_played_cards, get_draft_rating
- [ ] `python -m arenamcp.server` runs without immediate crash (may wait for input on STDIO)
</verification>

<success_criteria>

- FastMCP server created with STDIO transport
- All four tools implemented and registered
- Card serialization includes oracle text (Calculator + Coach pattern)
- Watcher/parser/gamestate properly wired together
- Server can be run via `python -m arenamcp.server`
- Phase 4 complete, project milestone complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-server/04-01-SUMMARY.md`:

# Phase 4 Plan 1: MCP Server Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `src/arenamcp/server.py` - FastMCP server with tools
- `src/arenamcp/__init__.py` - Updated exports

## Decisions Made

[Any runtime decisions]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Project complete - all four phases delivered. Ready for integration testing with Claude Code.
</output>
